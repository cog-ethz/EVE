using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using System;
using UnityEngine.Networking;

/// <summary>
///   The pop up evalaution map allows experiments to quickly view participants paths
///   through an experiment scene.
/// </summary>
/// <revisionHistory visible="true">
///   <revision date = "2016-08-19" version="0.1.1.1" author="Jascha Grübel" visible="true">
///     Introduce dynamic map loading.
///   </revision>
/// </revisionHistory>
public class PopUpEvaluationMap : MonoBehaviour
{
    //General settings
    [Tooltip("Texture for the participant path.")]
    public Texture participantPathTexture;
    [Tooltip("Texture of the close button.")]
    public Texture closeX;
    [Tooltip("Map height on the evaluation screen.")]
    public float mapHeight = 520;
    [Tooltip("Map width on the evaluation screen.")]
    public float mapWidth = 520;
    [Tooltip("Width of the original map.")]
    public int ResolutionWidth = 2048;
    [Tooltip("Height of the original map.")]
    public int ResolutionHeight = 2048;

    //Derived settings data
    private float top;
    private float left;
    private Vector2 size;
    private bool displayMapPopup;

    //map data
    private List<Vector2> participantLocationsOnMap = new List<Vector2>();
    private Matrix4x4 projectionMatrix;
    private Matrix4x4 worldToCameraMatrix;
    private Texture mapTexture;
    private List<string> uniqueNames;
    private string currentMapToDisplay;

    /// <summary>
    /// Initialised derived settings.
    /// </summary>
    public void Awake()
    {
        displayMapPopup = false;

        // calculate size of the map on screen
        top = (Screen.height - mapHeight) / 2.0f;
        left = (Screen.width - mapWidth) / 2.0f;
        size = new Vector2(participantPathTexture.width, participantPathTexture.height);
    }

    /// <summary>
    /// Displays the popup map.
    /// </summary>
    public void OnGUI()
    {
        if (displayMapPopup)
        {
            GUI.depth = 0;

            //draw background texture
            GUI.DrawTexture(new Rect(left, top, mapWidth, mapHeight), mapTexture);
            

            //draw participant path
            for (var i = 0; i < participantLocationsOnMap.Count; i++)
            {
                GUI.DrawTexture(new Rect(participantLocationsOnMap[i], size), participantPathTexture);
            }

            // Show close button
            if (GUI.Button(new Rect(left + mapWidth * 1.02f, top + mapHeight * -0.04f, 40f, 40f), closeX, GUIStyle.none))
            {
                displayMapPopup = false;
                Destroy(gameObject);
            }
        }
    }

    /// <summary>
    /// Opens a map displaying a participants route through the scene.
    /// </summary>
    /// <param name="xyz">Participant's location data, first array is rows, second is columns</param>
    /// <param name="mapName">Name of the scene</param>
    public void OpenPopUpMap(List<float>[] xyz, string mapName)
    {
        currentMapToDisplay = mapName;
        displayMapPopup = true;
        var top = (Screen.height - mapHeight) / 2;
        var left = (Screen.width - mapWidth) / 2;
        participantLocationsOnMap.Clear();
        var tempParticipantLocationsOnMap = new List<Vector2>();
        
        for (var i = 0; i < xyz[0].Count; i++)
        {
            var worldLocation = new Vector3(xyz[0][i], xyz[1][i], xyz[2][i]);
            var screenPoint = projectionMatrix.MultiplyPoint(worldToCameraMatrix.MultiplyPoint(worldLocation));
            var screenPixel = new Vector2(left + (screenPoint[0]+1.0f)* 0.5f * mapWidth, top + (-screenPoint[1] + 1.0f) * 0.5f * mapHeight);

            tempParticipantLocationsOnMap.Add(screenPixel);
        }
        for (var i = 0; i < tempParticipantLocationsOnMap.Count - 1; i++)
        {
            var a = tempParticipantLocationsOnMap[i];
            var b = tempParticipantLocationsOnMap[i + 1];
            var dist = (int)(a - b).magnitude + 1;
            for (var j = 0; j <= dist; j++)
            {
                participantLocationsOnMap.Add(a + (b - a) * ((float)j / dist));
            }
        }
    }

    /// <summary>
    /// Loads all maps from the persistent data path.
    /// </summary>
    /// <remarks>
    /// The maps need to be generated by placing an `EvaluationCamera`-Prefab in the scene.
    /// </remarks>
    /// <param name="envNames">List of map names</param>
    internal void SetupMaps(string name)
    {
        try
        {
            var path = Application.persistentDataPath + "/maps/" + name + "_worldToCameraMatrix.xml";

            var xmls = new XmlSerializer(new Matrix4x4().GetType());
            using (var stream = File.OpenRead(path))
            {
                worldToCameraMatrix = (Matrix4x4)xmls.Deserialize(stream);
            }
            path = Application.persistentDataPath + "/maps/" + name + "_projectionMatrix.xml";
            using (var stream = File.OpenRead(path))
            {
                projectionMatrix = (Matrix4x4)xmls.Deserialize(stream);
            }
            StartCoroutine(LoadMap(name, ResolutionWidth, ResolutionHeight));
        }
        catch (Exception ex)
        {
            Debug.LogWarning("A matrix for " + name + " was not found:\n" + ex.StackTrace);
        }
        

    }

    /// <summary>
    /// Loads the map as a resource from the persistent data path
    /// </summary>
    /// <param name="mapName"></param>
    /// <returns></returns>
    private IEnumerator LoadMap(string mapName, int width, int height)
    {
        var path = "file:///" + Application.persistentDataPath + "/maps/" + mapName + "_" + width + "x" + height +
                   ".png";
        
        var uwr = new UnityWebRequest(path);
        yield return uwr.SendWebRequest();
        if (uwr.isNetworkError || uwr.isHttpError)
        {
            Debug.Log(uwr.error);
        }
        else
        {
            mapTexture = DownloadHandlerTexture.GetContent(uwr);
        }
    }
}
